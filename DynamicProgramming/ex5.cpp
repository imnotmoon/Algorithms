// 백준 14852

// 타일의 종류가 3가지
// 역시 앞에 n개의 타일이 있다고 가정
// +1 : 2가지 경우가 존재
// +2 : 3가지 경우가 존재
// +3 : 2가지 경우가 존재(12/21, 21/12)
// 여기서 끝내면 안됨
// +4 : 2가지 방법이 더 존재함
// +5 : 역시 2가지 방법이 더 존재함
// D[n] = 2*D[n-1] + 3*D[n-2] + (2*D[n-3] + 2*D[n-4]+ .. 2*D[0])

#include <stdio.h>

int d[1000001];
long long d2[1000001][2];

int dp(int x) {
    if(x == 0) return 1;
    if(x == 1) return 2;
    if(x == 2) return 7;

    if(d[x] != 0) return d[x];

    int result = 3 * dp(x-2) + 2 * dp(x-1);
    for(int i = 3; i<=x; i++) {
        result += (2 * dp(x-i)) % 1000000007;
    }
    return d[x] = result % 1000000007;
}

// 2차원 dp 공부해야함
// O(n)
long long dp2(int x) {
    d2[0][0] = 0;
    d2[1][0] = 2;
    d2[2][0] = 7;
    d2[2][1] = 1;
    // 뭔가 2열짜리 표를 만들고 적당히 수를 채워서
    // 점화식을 더 간단하게 푸는듯
    for(int i=3; i<=x; i++) {
        d2[i][1] = (d2[i-1][1] + d2[i-3][0]) % 1000000007;
        d2[i][0] = (3 * d2[i-2][0] + 2 * d2[i-1][0] + 2 * d2[i][1]) % 1000000007;
    }
    return d2[x][0];
}

int main(void) {
    int x;
    scanf("%d", &x);
    printf("%lld", dp2(x));
}

// 위에껀 시간초과 나옴 => 2차원 동적프로그래밍 기법
// result += (2 * dp(x-i)) % 1000000007; 이부분이
// *2라서 dp개념이 사용될 수 있는거임
