
Dynamic Programming

하나의 문제를 단 한번만 풀도록 하는 알고리즘
- 분할 정복 기법은 동일한 문제를 다시 푼다는 단점.
    - ex. fibonacci 수열
    - 정렬은 이런 단점이 없음.

- 재귀적인 문제들에 적용이 가능

아래 가정 하에 사용 가능
1. 큰 문제를 작은 문제로 나눌 수 있다.(분할정복)
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일함. - 핵심
    - Memoization : 이미 구한 값을 잠시 기록해두는 것.

---------------------------------------------------------

작은 문제의 결과는 별도의 메모리 영역에 저장해서 다시 계산하지 않는다.
일반적으로 두가지 방식
- 탑다운
- 바텀업

다음의 조건을 만족할 때 사용할 수 있다.
1. 최적 부분 구조 : 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결
2. 중복 부분 문제 : 동일한 작은 문제를 반복적으로 해결해야 한다.

ex) 피보나치 수열 + 다이나믹 프로그래밍
    1. 큰 문제를 작은 문제로 나눌 수 있다.
    2. 동일한 작은 문제를 반복적으로 해결한다.
피보나치 수열은 다이나믹 프로그래밍의 사용 조건을 만족한다.
지수시간 -> 선형시간으로 시간복잡도가 감소된다.

다이나믹 프로그래밍을 구현하는 방법 2가지 : 상향식 / 하향식

메모이제이션 : 한번 계산한 결과를 메모리 공간에 메모하는 기법.
같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져온다.
값을 기록해놓는다는 점에서 캐싱(Caching) 이라고도 한다.
이전에 계산된 결과를 일시적으로 기록해놓는 넓은 개념을 의미한다.
    한번 계산된 결과를 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있다.
    (엄밀히 말하면 메모이제이션과 다이나믹 프로그래밍은 다른 개념이다.)

1. 탑다운 : 하향식. 재귀함수를 사용. 작은 문제를 해결했을때 큰 문제의 답도 얻을 수 있도록. 메모이제이션 이용
2. 바텀업 : 상향식. 반복문 사용. 작은문제를 하나씩 구해서 그 다음 문제를 차례대로 해결.
    다이나믹 프로그래밍의 전형적인 형태는 바텀업 방식
==> '재귀' / 반복문

큰 문제를 작은 문제로 나누어 큰 문제를 해결하는 상황을 만든다는것 : 분할정복과 공통점
반면
분할정복 : 같은 문제를 반복적으로 계산하지 않는다.
다이나믹 프로그래밍 : 같은 문제를 반복적으로 계산한다.
ex) 퀵정렬의 경우 한번 처리한 피벗을 다시 처리하는 부분문제를 호출하지 않는다(분할정복)

다이나믹 프로그래밍 문제에 접근하는 방법
1. 주어진 문제가 다이나믹 프로그래밍 유형임을 파악하는 것이 중요.
    가장 먼저 그리디, 구현, 완전탐색 등의 아이디어로 해결할 수 있는지 검토한다.
    다른 알고리즘으로 풀이 방법이 떠오르지 않으면 DP를 고려해본다.
    (반복적인 부분 문제 등장 + 큰 문제를 작은 문제로 나눌 수 있는 경우)
2. 일단 재귀함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤에 (탑다운)
    작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면, 코드를 개선시킬 수도 있음.
3. 매우 많은 종류의 유형이 존재. 서로 다른 점화식을 요구하기도 한다.
    (굉장히 어렵게도 낼 수 있지만 코테에서는 일반적으로 그렇게까지 어렵게는 안낸다.)
    => 반복적인 연습을 통해서 유형에 익숙해지면 코딩테스트에서도 괜찮게 풀 수 있다.



----- 문제풀이 -----

- 개미 전사 (얻을 수 있는 식량의 최대값을 구한다)
왼쪽부터 차례로 식량 창고를 턴다. 특정한 i번재 식량창고에 대해서 털지 안털지의 여부를 결정
두가지 경우 중에서 더 많은 식량을 털 수 있는 경우를 선택한다.
i-1과 i-2중 큰 경우가 될 것이다.

i-3부터는 안봐도 되나? : 
앞쪽에서 이미 고려가 되었고 털 수 있는 식량의 최대값이기 때문에 하나라도 더 털어야 한다.
한칸 이상 떨어진 식량창고는 항상 털 수 있다.

점화식으로 표현하면
a[i] = max(a[i-1], a[i-2]) + k[i]

N=4일때 경우의 수는 8가지. 
ai를 i번재 식량창고까지의 최적의 해라고 정의해 dp를 적용한다.



- 1로 만들기
5로 나누어 떨어지면 5로 나누고, 3으로 나누어 떨어지면 3으로 나누고, 2로 나누어 떨어지면 2로 나눈다
1을 뺀다.
이 4개의 연산을 적절히 사용해서 1을 만들려고 할 때 사용하는 연산의 횟수의 최소값

최적 부분 구조와 중복부분 문제를 만족한다.
ex. 6일때 : 5, 3, 2의 해 중 가장 작은 값 + 1. 단 여기서 5로 나누어 떨어지는 경우는 고려하지 않아도 된다.
비슷한 그리디 문제도 있는데 그리디는 당장 나누는게 더 연산횟수를 줄이는데 도움이 되기 때문에 다르다.
26에서 그리디는 2로 나눈다.


- 효율적인 화폐 구성
N가지 종류의 화폐. 개수를 최소한으로 이용해서 가치의 합이 M원. 화페의 종류는 몇개라도 사용 가능하다.
ex. 2원, 3원 단위의 화페 : 15원을 만들기 위해서는 3원짜리를 5개 쓰는게 좋다.
불가능하면 -1

a[i] : 금액 i를 만들 수 있는 최소한의 화폐 개수. INF로 초기화
k : 각 화폐의 단위.
점화식 : 
    a[i-k]를 만드는 방법이 존재하는 경우 : a[i] = min(a[i], a[i-k]+1)
    a[i-k]를 만드는 방법이 존재하지 않는 경우 : a[i] = INF
반복문을 이용해서 테이블의 값을 갱신한다.
작은걸 만들 수 있는지 확인해야 하기 때문에 재귀보다 반복문을 돌린다.

2인 경우, 3인 경우, 5의 경우 모두 각각 반복문을 돌린다.
반복문 하나에서 3가지 경우를 모두 생각하는것보다
이중반복문을 써서 각각의 경우를 따로 확인해보는 것이 유리하다.


- 금광 문제
n x m 크기의 금광. 첫번째 열부터 출발해서 금을 캔다. 
매번 오른쪽 위, 오른쪽 아래, 오른쪽 3가지 중 하나의 위치로 이동해야 한다.
이후 m-1번에 거쳐 3가지 중 하나의 길로 이동. 채굴자가 얻을 수 있는 금의 최대 크기를 구하라

금광의 "모든 위치"에 대해 다음의 세가지만 고려하면 된다.
(왼쪽 위, 왼쪽 아래, 왼쪽) 중 minimum => 현재 값.
dp[i][j] : i행 j열 까지의 최적의 해
"모든 위치"에 대해서 구해야 한다.
행->열 반복이 아니라 열->행 반복을 해야겠다.
리스트 범위를 벗어나는지도 체크. 벗어난다면 그 경우를 제외한다.


- 병사 배치하기 문제
N명의 병사가 무작위로 나열. 특정한 값의 전투력을 보유. 전투력이 높은 병사가 앞쪽에 오도록 내림차순 배치.
특정한 위치의 병사를 열외하는 방식으로 정렬 + 남아있는 병사의 수가 최대가 되도록

기본 아이디어 : 가장 긴 증가하는 부분 수열(LIS) 문제. (이 문제에서는 감소하는 부분을 찾는다.)
LIS를 구하는 DP : 
    이중포문. i, j(<i). 모든 원소마다 그 이전 원소들을 전부 확인하면서
    해당 원소보다 작은 원소가 있다면 그 원소의 dp값에 +1. 이거의 max.