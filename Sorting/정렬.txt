1. 선택정렬
- 가장 작은 것을 선택해서 제일 앞으로(바꿔서)
- 하나 정렬하면 n-1개에 대해서만 수행(앞에서 하나씩 빠짐)
- O(n! = n^2)
- for{for{}}
- code -> selectionSort.cpp

2. 버블정렬
- 옆에 있는 값과 비교해서 더 작은 값을 앞으로 보냄 == 가장 큰게 맨뒤로 보내짐
- 다음 루프때는 이전꺼보다 한개 적은 갯수만큼 비교(마지막에서 하나씩 빠짐)
- 효율성이 가장 떨어짐
- O(n! = n^2)
- code -> bubbleSort.cpp

3. 삽입정렬
- 각 숫자를 적절한 위치에 삽입 -> 필요할 때만 위치를 바꿔서 효율적
- O(n^2)이지만 그나마 제일 나음
- 앞에있는 원소들이 이미 정렬되어있다고 가정.
- 1 10 : 10은 1보다 크므로 1 오른쪽으로 삽입(유지)
- 1 10 5 : 1과 10 사이에 5가 들어감
- 하나 이전의 원소와 계속 비교하다가 자기보다 작은 숫자를 만나면 멈춤
- code -> insertionSort.cpp

4. 퀵정렬
- O(nlogn)
- 특정 값을 기준으로 큰 숫자와 작은 숫자를 나눔 -> 기준값(Pivot)
- 보통 맨 앞 값을 pivot으로 설정
- 분할정복이 강력한 이유 : n = 10일때 n^2 = 100, 반씩 쪼개면 25+25=50
- 피봇값 다음부터 ->, 맨 뒤에서부터 <-
    - 피봇보다 작은것과 큰것을 찾아서
    - 둘이 교차하지 않는다면 서로 교체
    - 둘이 교차하면 피봇과 작은걸 교체
- 최악의 경우 O(n^2)
    - 이미 정렬이 되어있는 경우 : 1 2 3 4 5 6 7 8 9 10
        - 매번 교차하고 작은거 큰거 찾기위해 훑으면서 n, n-1, n-2... -> n^2
    - 정렬할 데이터의 특성에 따라서 최적의 알고리즘을 고르는게 중요함
- 대부분의 경우에서는 가장 효율적
- 문제) 단 두가지 부분만 바꿔서 내림차순 소스코드로 변경
    - : 피벗보다 큰값 작은값 분류할때 부등호만 바꾸면 됨

5. STL sort()
- 대회나 실무에서는 이걸쓰자
    - 대회나 코테에서는 클래스를 만들기엔 시간이 부족하니 Pair를 사용
- #inlcude <algorithm>
- sort, compare 함수를 인자로 넣어서 정렬기준 바꾸기
- 객체 정렬(연산자 오버로딩)

