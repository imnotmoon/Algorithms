1. 선택정렬
- 가장 작은 것을 선택해서 제일 앞으로(바꿔서)
- 하나 정렬하면 n-1개에 대해서만 수행(앞에서 하나씩 빠짐)
- O(n! = n^2)
- for{for{}}
- code -> selectionSort.cpp

2. 버블정렬
- 옆에 있는 값과 비교해서 더 작은 값을 앞으로 보냄 == 가장 큰게 맨뒤로 보내짐
- 다음 루프때는 이전꺼보다 한개 적은 갯수만큼 비교(마지막에서 하나씩 빠짐)
- 효율성이 가장 떨어짐
- O(n! = n^2)
- code -> bubbleSort.cpp

3. 삽입정렬
- 각 숫자를 적절한 위치에 삽입 -> 필요할 때만 위치를 바꿔서 효율적
- O(n^2)이지만 그나마 제일 나음
- 앞에있는 원소들이 이미 정렬되어있다고 가정.
- 1 10 : 10은 1보다 크므로 1 오른쪽으로 삽입(유지)
- 1 10 5 : 1과 10 사이에 5가 들어감
- 하나 이전의 원소와 계속 비교하다가 자기보다 작은 숫자를 만나면 멈춤
- code -> insertionSort.cpp