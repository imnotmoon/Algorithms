1. 선택정렬
- 가장 작은 것을 선택해서 제일 앞으로(바꿔서)
- 하나 정렬하면 n-1개에 대해서만 수행(앞에서 하나씩 빠짐)
- O(n! = n^2)
- for{for{}}
- code -> selectionSort.cpp

2. 버블정렬
- 옆에 있는 값과 비교해서 더 작은 값을 앞으로 보냄 == 가장 큰게 맨뒤로 보내짐
- 다음 루프때는 이전꺼보다 한개 적은 갯수만큼 비교(마지막에서 하나씩 빠짐)
- 효율성이 가장 떨어짐
- O(n! = n^2)
- code -> bubbleSort.cpp

3. 삽입정렬
- 각 숫자를 적절한 위치에 삽입 -> 필요할 때만 위치를 바꿔서 효율적
- O(n^2)이지만 그나마 제일 나음
- 앞에있는 원소들이 이미 정렬되어있다고 가정.
- 1 10 : 10은 1보다 크므로 1 오른쪽으로 삽입(유지)
- 1 10 5 : 1과 10 사이에 5가 들어감
- 하나 이전의 원소와 계속 비교하다가 자기보다 작은 숫자를 만나면 멈춤
- code -> insertionSort.cpp

4. 퀵정렬
- O(nlogn)
- 특정 값을 기준으로 큰 숫자와 작은 숫자를 나눔 -> 기준값(Pivot)
- 보통 맨 앞 값을 pivot으로 설정
- 분할정복이 강력한 이유 : n = 10일때 n^2 = 100, 반씩 쪼개면 25+25=50
- 피봇값 다음부터 ->, 맨 뒤에서부터 <-
    - 피봇보다 작은것과 큰것을 찾아서
    - 둘이 교차하지 않는다면 서로 교체
    - 둘이 교차하면 피봇과 작은걸 교체
- 최악의 경우 O(n^2)
    - 이미 정렬이 되어있는 경우 : 1 2 3 4 5 6 7 8 9 10
        - 매번 교차하고 작은거 큰거 찾기위해 훑으면서 n, n-1, n-2... -> n^2
    - 정렬할 데이터의 특성에 따라서 최적의 알고리즘을 고르는게 중요함
- 대부분의 경우에서는 가장 효율적
- 문제) 단 두가지 부분만 바꿔서 내림차순 소스코드로 변경
    - : 피벗보다 큰값 작은값 분류할때 부등호만 바꾸면 됨

5. STL sort()
- 대회나 실무에서는 이걸쓰자
    - 대회나 코테에서는 클래스를 만들기엔 시간이 부족하니 Pair를 사용
- #inlcude <algorithm>
- sort, compare 함수를 인자로 넣어서 정렬기준 바꾸기
- 객체 정렬(연산자 오버로딩)

6. 병합정렬
- 퀵정렬은 피벗값에 따라 편향되게 분할될 가능성이 있음
- 병합정렬은 정확히 반씩 쪼개기 때문에 최악의 경우에도 O(nlogn)을 보장
- 7 6 5 8 3 5 9 1
- 계속 반으로 쪼개고 나중에 합쳐서 정렬하는 방식 >> 이게 logn을 보장함
- 분할정복
- 합치는 순간에 정렬한다
- 합치는 과정에서 작은 두개의 배열에서 인덱스 두개, 합쳐질 배열에서의 인덱스 하나
    - 작은 두개의 배열은 합쳐진 상태라고 가정한다

7. 힙정렬
- O(nlogn)이 나옴
- 고급프로그래밍 기법으로 갈수록 힙의 개념이 자주 등장
- 힙 트리 구조를 이용하는 정렬방법
- 힙 : 
    - 이진트리 : 최대 2개의 자식을 갖는 트리
    - 완전이진트리 : 데이터가 왼쪽/오른쪽 차근차근 들어가는 구조, 아주 빽빽하게 들어섬
        - 그냥 배열에 순서대로 박아도 됨
    - 최대힙 : 제일 큰 값이 루트
    - 최소힙 : 제일 작은 값이 루트
    - 특정 노드때문에 최대힙이 붕괴되는 경우 -> 자식 중 큰 값과 교체(Heapify)
- 트리를 돌면서 Heapify -> 트리의 높이만큼의 시간이 걸림 -> 트리생성 끝
- 실제는 1/2n logn. 리프에서는 Heapify 안하니까 -> O(n)
- Heapify는 리프 바로 위부터 수행(상향식) // 하향식도 가능. 자기맘
- 정렬(오름차순)
    - 루트 노드를 맨 마지막과 바꾸고 Heapify.
    - 맨 마지막 인덱스의 노드를 제외한 나머지에 대해서 위 과정 반복
- 힙을 만드는 시간복잡도 : log n
- Heapify를 노드 개수 반만큼만 반복해서 수행 : log n

8. 계수정렬 (Counting Sort)
- 범위를 조건으로 주고 정렬, 범위가 한정되어있는 배열에 대해서만 정렬이 가능
- O(n)
- 크기를 기준으로 갯수를 센다
- 크기가 1인 경우 / 2인 경우 / 3인 경우 / 4인 경우 / 5인 경우의 개수를 셈
- >> 1을 센 개수만큼 출력, 2를 센 개수만큼 출력, ...
